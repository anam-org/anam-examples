var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { SignalMessageAction, } from '../types';
const DEFAULT_HEARTBEART_INTERVAL_SECONDS = 5;
const DEFAULT_WS_RECONNECTION_ATTEMPTS = 5;
export class SignallingClient {
    constructor(sessionId, options, onSignalMessageReceivedCallback, onClientConnectedCallback, onClientConnectionFailureCallback) {
        var _a;
        this.stopSignal = false;
        this.sendingBuffer = [];
        this.wsConnectionAttempts = 0;
        this.socket = null;
        this.heartBeatIntervalRef = null;
        if (!sessionId) {
            throw new Error('Signalling Client: sessionId is required');
        }
        this.sessionId = sessionId;
        if (onSignalMessageReceivedCallback) {
            this.onSignalMessageReceivedCallback = onSignalMessageReceivedCallback;
        }
        if (onClientConnectedCallback) {
            this.onClientConnectedCallback = onClientConnectedCallback;
        }
        if (onClientConnectionFailureCallback) {
            this.onClientConnectionFailureCallback =
                onClientConnectionFailureCallback;
        }
        const { heartbeatIntervalSeconds, maxWsReconnectionAttempts, url } = options;
        this.heartbeatIntervalSeconds =
            heartbeatIntervalSeconds || DEFAULT_HEARTBEART_INTERVAL_SECONDS;
        this.maxWsReconnectionAttempts =
            maxWsReconnectionAttempts || DEFAULT_WS_RECONNECTION_ATTEMPTS;
        if (!url.baseUrl) {
            throw new Error('Signalling Client: baseUrl is required');
        }
        const httpProtocol = url.protocol || 'https';
        const initUrl = `${httpProtocol}://${url.baseUrl}`;
        this.url = new URL(initUrl);
        this.url.protocol = url.protocol === 'http' ? 'ws:' : 'wss:';
        if (url.port) {
            this.url.port = url.port;
        }
        this.url.pathname = (_a = url.signallingPath) !== null && _a !== void 0 ? _a : '/ws';
        this.url.searchParams.append('session_id', sessionId);
    }
    stop() {
        this.stopSignal = true;
        this.closeSocket();
    }
    connect() {
        this.socket = new WebSocket(this.url.href);
        this.socket.onopen = this.onOpen.bind(this);
        this.socket.onclose = this.onClose.bind(this);
        this.socket.onerror = this.onError.bind(this);
        return this.socket;
    }
    sendOffer(localDescription) {
        return __awaiter(this, void 0, void 0, function* () {
            const offerMessagePayload = {
                connectionDescription: localDescription,
                userUid: this.sessionId, // TODO: this should be renamed to session Id on the server
            };
            const offerMessage = {
                actionType: SignalMessageAction.OFFER,
                sessionId: this.sessionId,
                payload: offerMessagePayload,
            };
            this.sendSignalMessage(offerMessage);
        });
    }
    sendIceCandidate(candidate) {
        return __awaiter(this, void 0, void 0, function* () {
            const iceCandidateMessage = {
                actionType: SignalMessageAction.ICE_CANDIDATE,
                sessionId: this.sessionId,
                payload: candidate.toJSON(),
            };
            this.sendSignalMessage(iceCandidateMessage);
        });
    }
    sendSignalMessage(message) {
        var _a;
        if (((_a = this.socket) === null || _a === void 0 ? void 0 : _a.readyState) === WebSocket.OPEN) {
            try {
                this.socket.send(JSON.stringify(message));
            }
            catch (error) {
                console.error('SignallingClient - sendSignalMessage: error sending message', error);
            }
        }
        else {
            this.sendingBuffer.push(message);
        }
    }
    closeSocket() {
        if (this.socket) {
            this.socket.close();
            this.socket = null;
        }
        if (this.heartBeatIntervalRef) {
            clearInterval(this.heartBeatIntervalRef);
            this.heartBeatIntervalRef = null;
        }
    }
    onOpen() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.socket) {
                throw new Error('SignallingClient - onOpen: socket is null');
            }
            try {
                this.wsConnectionAttempts = 0;
                this.flushSendingBuffer();
                this.socket.onmessage = this.onMessage.bind(this);
                this.startSendingHeartBeats();
                if (this.onClientConnectedCallback) {
                    yield this.onClientConnectedCallback();
                }
            }
            catch (e) {
                console.error('SignallingClient - onOpen: error in onOpen', e);
                if (this.onClientConnectionFailureCallback) {
                    this.onClientConnectionFailureCallback();
                }
            }
        });
    }
    onClose() {
        return __awaiter(this, void 0, void 0, function* () {
            this.wsConnectionAttempts += 1;
            if (this.stopSignal) {
                return;
            }
            if (this.wsConnectionAttempts <= this.maxWsReconnectionAttempts) {
                this.socket = null;
                setTimeout(() => {
                    this.connect();
                }, 100 * this.wsConnectionAttempts);
            }
            else {
                if (this.heartBeatIntervalRef) {
                    clearInterval(this.heartBeatIntervalRef);
                    this.heartBeatIntervalRef = null;
                }
                if (this.onClientConnectionFailureCallback) {
                    this.onClientConnectionFailureCallback();
                }
            }
        });
    }
    onError(event) {
        if (this.stopSignal) {
            return;
        }
        console.error('SignallingClient - onError: ', event);
    }
    flushSendingBuffer() {
        const newBuffer = [];
        if (this.sendingBuffer.length > 0) {
            this.sendingBuffer.forEach((message) => {
                var _a;
                if (((_a = this.socket) === null || _a === void 0 ? void 0 : _a.readyState) === WebSocket.OPEN) {
                    this.socket.send(JSON.stringify(message));
                }
                else {
                    newBuffer.push(message);
                }
            });
        }
        this.sendingBuffer = newBuffer;
    }
    onMessage(event) {
        return __awaiter(this, void 0, void 0, function* () {
            const message = JSON.parse(event.data);
            if (this.onSignalMessageReceivedCallback) {
                yield this.onSignalMessageReceivedCallback(message);
            }
        });
    }
    startSendingHeartBeats() {
        if (!this.socket) {
            throw new Error('SignallingClient - startSendingHeartBeats: socket is null');
        }
        if (this.heartBeatIntervalRef) {
            console.warn('SignallingClient - startSendingHeartBeats: heartbeat interval already set');
        }
        // send a heartbeat message every heartbeatIntervalSeconds
        const heartbeatInterval = this.heartbeatIntervalSeconds * 1000;
        const heartbeatMessage = {
            actionType: SignalMessageAction.HEARTBEAT,
            sessionId: this.sessionId,
            payload: '',
        };
        const heartbeatMessageJson = JSON.stringify(heartbeatMessage);
        this.heartBeatIntervalRef = setInterval(() => {
            var _a;
            if (this.stopSignal) {
                return;
            }
            if (((_a = this.socket) === null || _a === void 0 ? void 0 : _a.readyState) === WebSocket.OPEN) {
                this.socket.send(heartbeatMessageJson);
            }
        }, heartbeatInterval);
    }
}
//# sourceMappingURL=SignallingClient.js.map