var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { CoreApiRestClient } from './modules/CoreApiRestClient';
import { StreamingClient } from './modules/StreamingClient';
export default class AnamClient {
    constructor(sessionToken, personaConfig, options) {
        this.sessionId = null;
        this.streamingClient = null;
        this._isStreaming = false;
        this.inputAudioState = { isMuted: false };
        if (!sessionToken && !(options === null || options === void 0 ? void 0 : options.apiKey)) {
            throw new Error('Either sessionToken or apiKey must be provided');
        }
        this.sessionToken = sessionToken;
        this.apiKey = options === null || options === void 0 ? void 0 : options.apiKey;
        this.personaConfig = personaConfig;
        this.apiClient = new CoreApiRestClient(sessionToken, options === null || options === void 0 ? void 0 : options.apiKey, options === null || options === void 0 ? void 0 : options.api);
    }
    startSession(userProvidedAudioStream) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const config = this.personaConfig;
                if (!config) {
                    throw new Error('A default persona configuration has not been set and no persona configuration was provided');
                }
                const response = yield this.apiClient.startSession(config);
                const { sessionId, clientConfig, engineHost, engineProtocol, signallingEndpoint, } = response;
                const { heartbeatIntervalSeconds, maxWsReconnectionAttempts, iceServers, } = clientConfig;
                // create a new streaming client
                this.streamingClient = new StreamingClient(sessionId, {
                    engine: {
                        baseUrl: `${engineProtocol}://${engineHost}`,
                    },
                    signalling: {
                        heartbeatIntervalSeconds,
                        maxWsReconnectionAttempts,
                        url: {
                            baseUrl: engineHost,
                            protocol: engineProtocol,
                            signallingPath: signallingEndpoint,
                        },
                    },
                    iceServers,
                    inputAudio: {
                        inputAudioState: this.inputAudioState,
                        userProvidedMediaStream: userProvidedAudioStream,
                    },
                });
                this.sessionId = sessionId;
                return sessionId;
            }
            catch (error) {
                throw new Error('Failed to start session');
            }
        });
    }
    startSessionIfNeeded(userProvidedMediaStream) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.sessionId || !this.streamingClient) {
                try {
                    yield this.startSession(userProvidedMediaStream);
                }
                catch (error) {
                    throw new Error('StreamToVideoAndAudioElements: Failed to start session');
                }
                if (!this.sessionId || !this.streamingClient) {
                    throw new Error('StreamToVideoAndAudioElements: session Id or streaming client is not available after starting session');
                }
            }
        });
    }
    stream() {
        return __awaiter(this, arguments, void 0, function* (callbacks = {}, userProvidedAudioStream) {
            yield this.startSessionIfNeeded(userProvidedAudioStream);
            if (this._isStreaming) {
                throw new Error('Already streaming');
            }
            this._isStreaming = true;
            return new Promise((resolve) => {
                var _a, _b, _c;
                // set stream callbacks to capture the stream
                const streams = [];
                let videoReceived = false;
                let audioReceived = false;
                (_a = this.streamingClient) === null || _a === void 0 ? void 0 : _a.setOnVideoStreamStartCallback((videoStream) => {
                    streams.push(videoStream);
                    videoReceived = true;
                    if (audioReceived) {
                        resolve(streams);
                    }
                });
                (_b = this.streamingClient) === null || _b === void 0 ? void 0 : _b.setOnAudioStreamStartCallback((audioStream) => {
                    streams.push(audioStream);
                    audioReceived = true;
                    if (videoReceived) {
                        resolve(streams);
                    }
                });
                // start streaming
                (_c = this.streamingClient) === null || _c === void 0 ? void 0 : _c.startConnection(callbacks);
            });
        });
    }
    streamToVideoAndAudioElements(videoElementId_1, audioElementId_1) {
        return __awaiter(this, arguments, void 0, function* (videoElementId, audioElementId, callbacks = {}, userProvidedMediaStream) {
            yield this.startSessionIfNeeded(userProvidedMediaStream);
            if (this._isStreaming) {
                throw new Error('Already streaming');
            }
            this._isStreaming = true;
            if (!this.streamingClient) {
                throw new Error('Failed to stream: streaming client is not available');
            }
            this.streamingClient.setMediaStreamTargetsById(videoElementId, audioElementId);
            this.streamingClient.startConnection(callbacks);
        });
    }
    talk(content) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.streamingClient) {
                throw new Error('Failed to send talk command: session is not started. Have you called startSession?');
            }
            if (!this._isStreaming) {
                throw new Error('Failed to send talk command: not currently streaming. Have you called stream?');
            }
            yield this.streamingClient.sendTalkCommand(content);
            return;
        });
    }
    sendDataMessage(message) {
        if (this.streamingClient) {
            this.streamingClient.sendDataMessage(message);
        }
        else {
            throw new Error('Failed to send message: session is not started.');
        }
    }
    stopStreaming() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.streamingClient) {
                this.streamingClient.stopConnection();
                this.streamingClient = null;
                this.sessionId = null;
                this._isStreaming = false;
            }
        });
    }
    isStreaming() {
        return this._isStreaming;
    }
    setPersonaConfig(personaConfig) {
        this.personaConfig = personaConfig;
    }
    getPersonaConfig() {
        return this.personaConfig;
    }
    getInputAudioState() {
        // if streaming client is available, make sure our state is up to date
        if (this.streamingClient) {
            this.inputAudioState = this.streamingClient.getInputAudioState();
        }
        return this.inputAudioState;
    }
    muteInputAudio() {
        if (this.streamingClient) {
            this.inputAudioState = this.streamingClient.muteInputAudio();
        }
        else {
            this.inputAudioState = Object.assign(Object.assign({}, this.inputAudioState), { isMuted: true });
        }
        return this.inputAudioState;
    }
    unmuteInputAudio() {
        if (this.streamingClient) {
            this.inputAudioState = this.streamingClient.unmuteInputAudio();
        }
        else {
            this.inputAudioState = Object.assign(Object.assign({}, this.inputAudioState), { isMuted: false });
        }
        return this.inputAudioState;
    }
}
//# sourceMappingURL=AnamClient.js.map